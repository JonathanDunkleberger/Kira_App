================================================================================
KIRA PAYWALL / USAGE LIMITS / GOODBYE / UPGRADE FLOW ‚Äî ALL RELEVANT CODE
================================================================================

Table of Contents:
  1. packages/server/src/server.ts ‚Äî State vars & constants (lines 358‚Äì381)
  2. packages/server/src/server.ts ‚Äî Time context, goodbye, usage tracking (lines 1014‚Äì1170)
  3. packages/server/src/server.ts ‚Äî On-connect usage checks & interval timers (lines 1330‚Äì1530)
  4. packages/server/src/guestUsage.ts ‚Äî Full file
  5. packages/server/src/proUsage.ts ‚Äî Full file
  6. packages/web/src/hooks/useKiraSocket.ts ‚Äî State declarations (lines 130‚Äì145)
  7. packages/web/src/hooks/useKiraSocket.ts ‚Äî session_config handler (lines 1152‚Äì1170)
  8. packages/web/src/hooks/useKiraSocket.ts ‚Äî limit_reached + onClose (lines 1260‚Äì1380)
  9. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Imports & state (lines 1‚Äì30)
  10. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî handleUpgrade, handleSignUp, localRemaining (lines 230‚Äì290)
  11. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Timer in header (lines 455‚Äì475)
  12. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Error display area (lines 700‚Äì740)
  13. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Paywall overlays: free, pro, audio unlock (lines 800‚Äì1100)
  14. packages/web/src/app/page.tsx ‚Äî handleUpgrade (lines 130‚Äì148)
  15. packages/web/src/app/page.tsx ‚Äî Nav upgrade button (lines 218‚Äì242)
  16. packages/web/src/app/page.tsx ‚Äî Pricing section (lines 775‚Äì1010)
  17. packages/web/src/components/ProfileModal.tsx ‚Äî handleSubscription + Upgrade button (lines 1‚Äì50, 220‚Äì285)
  18. packages/web/src/app/api/stripe/checkout/route.ts ‚Äî Full file
  19. packages/web/src/app/api/stripe/portal/route.ts ‚Äî Full file
  20. packages/web/src/app/api/webhooks/stripe/route.ts ‚Äî Full file
  21. packages/web/src/lib/stripe.ts ‚Äî Full file
  22. packages/web/src/app/globals.css ‚Äî paywallFadeIn animation


================================================================================
1. packages/server/src/server.ts ‚Äî State vars & constants (lines 358‚Äì381)
================================================================================

  let timeWarningPhase: 'normal' | 'final_goodbye' | 'done' = 'normal';
  let goodbyeTimeout: NodeJS.Timeout | null = null;
  let isAcceptingAudio = false;
  ...
  let currentResponseId = 0; // generation ID ‚Äî prevents stale TTS callbacks from leaking audio into new turns


================================================================================
2. packages/server/src/server.ts ‚Äî Time context, goodbye, usage tracking (lines 1014‚Äì1170)
================================================================================

  // --- Time-context injection for graceful paywall ---
  function getTimeContext(): string {
    if (timeWarningPhase === 'final_goodbye') {
      return `\n\n[CRITICAL INSTRUCTION - MUST FOLLOW: This is your LAST response. Time is up. Keep your ENTIRE response to 1 sentence. Say a quick warm goodbye. Example: "Hey, that was really fun - come back and talk to me tomorrow, okay?" Do NOT continue the previous topic in depth. Just say bye.]`;
    }
    return '';
  }

  /** Build messages array with time + vision context injected into system prompt (without mutating chatHistory). */
  function getMessagesWithTimeContext(): OpenAI.Chat.ChatCompletionMessageParam[] {
    const timeCtx = getTimeContext();
    const visionCtx = visionActive ? VISION_CONTEXT_PROMPT : '';
    // Clone and inject time + vision context into the system prompt
    const messages = chatHistory.map((msg, i) => {
      if (i === 0 && msg.role === 'system' && typeof msg.content === 'string') {
        return { ...msg, content: msg.content + visionCtx + timeCtx };
      }
      return msg;
    });
    // Inject expression tag reminder as the last system message (right before user's message)
    // This keeps it at the edge of the model's attention window for maximum compliance.
    messages.push({ role: "system", content: EXPRESSION_TAG_REMINDER });
    return messages;
  }

  /** Advance timeWarningPhase after a response is sent during a warning phase. */
  function advanceTimePhase(responseText: string) {
    if (timeWarningPhase === 'final_goodbye') {
      timeWarningPhase = 'done';
      isAcceptingAudio = false;
      console.log('[TIME] final_goodbye ‚Üí done (goodbye delivered)');

      // Wait for TTS to finish playing on client, then disconnect
      const estimatedPlayTime = Math.max(2000, responseText.length * 80);
      setTimeout(() => {
        if (ws.readyState === ws.OPEN) {
          ws.send(JSON.stringify({ type: "error", code: "limit_reached", ...(isProUser ? { tier: "pro" } : {}) }));
          ws.close(1008, "Usage limit reached");
        }
      }, estimatedPlayTime);
    }
  }

  // Proactive goodbye when user doesn't speak during final phase
  async function sendProactiveGoodbye() {
    if (timeWarningPhase !== 'final_goodbye' || state !== 'listening' || clientDisconnected) return;
    if (ws.readyState !== ws.OPEN) return;

    timeWarningPhase = 'done';
    isAcceptingAudio = false;
    if (silenceTimer) clearTimeout(silenceTimer);

    try {
      const goodbyeMessages: OpenAI.Chat.ChatCompletionMessageParam[] = [
        { role: "system", content: KIRA_SYSTEM_PROMPT + `\n\n[CRITICAL INSTRUCTION - MUST FOLLOW: You must say goodbye RIGHT NOW. Time is up. Keep it to ONE short sentence. Be warm but fast. Reference something from the conversation. Example: "Hey, our time's up for today - but let's pick this up tomorrow, okay?"]` },
        ...chatHistory.filter(m => m.role !== "system").slice(-4),
        { role: "system", content: EXPRESSION_TAG_REMINDER },
        { role: "user", content: "[Time is up - say goodbye immediately]" },
      ];

      const response = await openai.chat.completions.create({
        model: OPENAI_MODEL,
        messages: goodbyeMessages,
        max_tokens: 60,
        temperature: 0.9,
      });

      const goodbyeText = response.choices[0]?.message?.content?.trim() || "";
      if (goodbyeText && goodbyeText.length > 2 && ws.readyState === ws.OPEN && !clientDisconnected) {
        // Parse expression tag and strip before TTS
        const goodbyeTagResult = handleNonStreamingTag(goodbyeText, "goodbye");
        const finalGoodbye = stripEmotionTags(goodbyeTagResult.text);
        const goodbyeEmotion = goodbyeTagResult.emotion;

        console.log(`[Goodbye] Kira says: "${finalGoodbye}"`);
        chatHistory.push({ role: "assistant", content: finalGoodbye });
        ws.send(JSON.stringify({ type: "transcript", role: "ai", text: finalGoodbye }));

        setState("speaking");
        ws.send(JSON.stringify({ type: "state_speaking" }));
        ws.send(JSON.stringify({ type: "tts_chunk_starts" }));
        await new Promise(resolve => setImmediate(resolve));

        const sentences = finalGoodbye.split(/(?<=[.!?\u2026])\s+(?=[A-Z"])/);
        let goodbyeSentIdx = 0;
        for (const sentence of sentences) {
          const trimmed = sentence.trim();
          if (trimmed.length === 0) continue;
          if (goodbyeSentIdx > 0) {
            const delay = EMOTION_SENTENCE_DELAY[goodbyeEmotion] || 0;
            if (delay > 0) await new Promise(resolve => setTimeout(resolve, delay));
          }
          goodbyeSentIdx++;
          await new Promise<void>((resolve) => {
            const tts = new AzureTTSStreamer({ ...currentVoiceConfig, emotion: goodbyeEmotion });
            tts.on("audio_chunk", (chunk: Buffer) => {
              if (!clientDisconnected && ws.readyState === ws.OPEN) ws.send(chunk);
            });
            tts.on("tts_complete", () => resolve());
            tts.on("error", (err: Error) => {
              console.error(`[Goodbye TTS] ‚ùå Chunk failed: "${trimmed}"`, err);
              resolve();
            });
            tts.synthesize(trimmed);
          });
        }

        ws.send(JSON.stringify({ type: "tts_chunk_ends" }));

        // Wait for TTS to finish playing on client, then disconnect
        const estimatedPlayTime = Math.max(2000, finalGoodbye.length * 80);
        setTimeout(() => {
          if (ws.readyState === ws.OPEN) {
            ws.send(JSON.stringify({ type: "error", code: "limit_reached", ...(isProUser ? { tier: "pro" } : {}) }));
            ws.close(1008, "Usage limit reached");
          }
        }, estimatedPlayTime);
      } else {
        // No goodbye text ‚Äî close immediately
        if (ws.readyState === ws.OPEN) {
          ws.send(JSON.stringify({ type: "error", code: "limit_reached", ...(isProUser ? { tier: "pro" } : {}) }));
          ws.close(1008, "Usage limit reached");
        }
      }
    } catch (err) {
      console.error("[Goodbye] Error:", (err as Error).message);
      if (ws.readyState === ws.OPEN) {
        ws.send(JSON.stringify({ type: "error", code: "limit_reached", ...(isProUser ? { tier: "pro" } : {}) }));
        ws.close(1008, "Usage limit reached");
      }
    }
  }

  // --- USAGE TRACKING ---
  const FREE_LIMIT_SECONDS = parseInt(process.env.FREE_TRIAL_SECONDS || "900"); // 15 min/day
  const PRO_MONTHLY_SECONDS = parseInt(process.env.PRO_MONTHLY_SECONDS || "360000"); // 100 hrs/month
  let sessionStartTime: number | null = null;
  let usageCheckInterval: NodeJS.Timeout | null = null;
  let timeCheckInterval: NodeJS.Timeout | null = null;
  let isProUser = false;
  let guestUsageSeconds = 0;
  let guestUsageBase = 0; // Accumulated seconds from previous sessions today
  let proUsageSeconds = 0;
  let proUsageBase = 0; // Accumulated seconds from previous sessions this month
  let wasBlockedImmediately = false; // True if connection was blocked on connect (limit already hit)


================================================================================
3. packages/server/src/server.ts ‚Äî On-connect usage checks & interval timers (lines 1330‚Äì1530)
================================================================================

              if (dbUser) {
                isProUser = !!(
                  dbUser.stripeSubscriptionId &&
                  dbUser.stripeCurrentPeriodEnd &&
                  dbUser.stripeCurrentPeriodEnd.getTime() > Date.now()
                );

                if (isProUser) {
                  // Pro users: monthly usage tracked in Prisma MonthlyUsage (resets per calendar month)
                  const storedSeconds = await getProUsage(userId);
                  if (storedSeconds >= PRO_MONTHLY_SECONDS) {
                    console.log(`[USAGE] Pro user ${userId} blocked ‚Äî ${storedSeconds}s >= ${PRO_MONTHLY_SECONDS}s`);
                    wasBlockedImmediately = true;
                    ws.send(JSON.stringify({ type: "error", code: "limit_reached", tier: "pro" }));
                    ws.close(1008, "Pro usage limit reached");
                    return;
                  }
                  proUsageSeconds = storedSeconds;
                  proUsageBase = storedSeconds;
                  console.log(`[USAGE] Pro user ${userId} allowed ‚Äî resuming at ${storedSeconds}s / ${PRO_MONTHLY_SECONDS}s`);

                  ws.send(JSON.stringify({
                    type: "session_config",
                    isPro: true,
                    remainingSeconds: PRO_MONTHLY_SECONDS - storedSeconds,
                  }));
                } else {
                  // Free signed-in users: daily usage tracked in Prisma
                  let currentUsage = dbUser.dailyUsageSeconds;
                  const today = new Date().toDateString();
                  const lastUsage = dbUser.lastUsageDate?.toDateString();
                  if (today !== lastUsage) {
                    currentUsage = 0;
                    await prisma.user.update({
                      where: { clerkId: userId },
                      data: { dailyUsageSeconds: 0, lastUsageDate: new Date() },
                    });
                  }

                  if (currentUsage >= FREE_LIMIT_SECONDS) {
                    ws.send(JSON.stringify({ type: "error", code: "limit_reached" }));
                    ws.close(1008, "Usage limit reached");
                    return;
                  }

                  ws.send(JSON.stringify({
                    type: "session_config",
                    isPro: false,
                    remainingSeconds: FREE_LIMIT_SECONDS - currentUsage,
                  }));
                }
              }

          // --- USAGE: Start session timer ---
          sessionStartTime = Date.now();

          // Send session_config for guests (signed-in users already get it above)
          let isReturningGuest = false;
          if (isGuest && userId) {
            const usageInfo = await getGuestUsageInfo(userId);

            if (usageInfo.seconds >= FREE_LIMIT_SECONDS) {
              console.log(`[USAGE] Guest ${userId} blocked ‚Äî ${usageInfo.seconds}s >= ${FREE_LIMIT_SECONDS}s`);
              wasBlockedImmediately = true;
              ws.send(JSON.stringify({ type: "error", code: "limit_reached" }));
              ws.close(1008, "Guest usage limit reached");
              return;
            }

            // Resume tracking from where they left off
            isReturningGuest = usageInfo.isReturning;
            guestUsageSeconds = usageInfo.seconds;
            guestUsageBase = usageInfo.seconds;
            console.log(`[USAGE] Guest ${userId} allowed ‚Äî resuming at ${usageInfo.seconds}s (returning: ${isReturningGuest})`);

            ws.send(
              JSON.stringify({
                type: "session_config",
                isPro: false,
                remainingSeconds: FREE_LIMIT_SECONDS - guestUsageSeconds,
              })
            );
          }

          // --- 30-SECOND INTERVAL: Usage tracking + DB writes ONLY ---
          // Phase transitions are handled by the faster 5-second interval below.
          usageCheckInterval = setInterval(async () => {
            if (!sessionStartTime) return;

            const elapsed = Math.floor(
              (Date.now() - sessionStartTime) / 1000
            );

            if (isGuest) {
              guestUsageSeconds = guestUsageBase + elapsed;

              // Persist to database so usage survives restarts/deploys
              await saveGuestUsage(userId!, guestUsageSeconds);
              console.log(`[USAGE] Guest ${userId}: ${guestUsageSeconds}s / ${FREE_LIMIT_SECONDS}s`);

              const remainingSec = FREE_LIMIT_SECONDS - guestUsageSeconds;

              // Hard limit: only force-close if goodbye system isn't handling it
              if (remainingSec <= 0) {
                if (timeWarningPhase === 'done' || timeWarningPhase === 'final_goodbye') {
                  console.log(`[USAGE] Over limit but in ${timeWarningPhase} phase ‚Äî letting goodbye system handle disconnect`);
                  return;
                }
                // Fallback: if somehow we got here without entering final_goodbye
                console.log(`[USAGE] Over limit, no goodbye phase active ‚Äî forcing final_goodbye`);
                timeWarningPhase = 'final_goodbye';
                // The 5-second interval will pick this up and handle the goodbye
              }
            } else if (userId) {
              if (isProUser) {
                // Pro users: monthly usage tracked in Prisma MonthlyUsage
                proUsageSeconds = proUsageBase + elapsed;
                await saveProUsage(userId, proUsageSeconds);
                console.log(`[USAGE] Pro ${userId}: ${proUsageSeconds}s / ${PRO_MONTHLY_SECONDS}s`);

                const proRemaining = PRO_MONTHLY_SECONDS - proUsageSeconds;
                if (proRemaining <= 0) {
                  if (timeWarningPhase === 'done' || timeWarningPhase === 'final_goodbye') {
                    console.log(`[USAGE] Pro over limit but in ${timeWarningPhase} phase ‚Äî letting goodbye system handle disconnect`);
                    return;
                  }
                  console.log(`[USAGE] Pro over limit, no goodbye phase active ‚Äî forcing final_goodbye`);
                  timeWarningPhase = 'final_goodbye';
                }
              } else {
                // Free signed-in users: daily usage tracked in Prisma
                try {
                  await prisma.user.update({
                    where: { clerkId: userId },
                    data: {
                      dailyUsageSeconds: { increment: 30 },
                      lastUsageDate: new Date(),
                    },
                  });

                  const dbUser = await prisma.user.findUnique({
                    where: { clerkId: userId },
                    select: { dailyUsageSeconds: true },
                  });

                  if (dbUser && dbUser.dailyUsageSeconds >= FREE_LIMIT_SECONDS) {
                    if (timeWarningPhase === 'done' || timeWarningPhase === 'final_goodbye') {
                      console.log(`[USAGE] Free user over limit but in ${timeWarningPhase} phase ‚Äî letting goodbye system handle disconnect`);
                      return;
                    }
                    console.log(`[USAGE] Free user over limit ‚Äî forcing final_goodbye`);
                    timeWarningPhase = 'final_goodbye';
                  }
                } catch (err) {
                  console.error("[Usage] DB update failed:", (err as Error).message);
                }
              }
            }
          }, 30000);

          // --- 5-SECOND INTERVAL: Time warning phase transitions ---
          // This runs frequently so we never skip the final_goodbye window.
          // It computes remaining time from the live elapsed counter, not from DB.
          timeCheckInterval = setInterval(() => {
            if (!sessionStartTime) return;
            if (timeWarningPhase === 'done') return;

            const elapsed = Math.floor((Date.now() - sessionStartTime) / 1000);

            // Compute remaining seconds based on user type
            let remainingSec: number | null = null;
            if (isGuest) {
              guestUsageSeconds = guestUsageBase + elapsed;
              remainingSec = FREE_LIMIT_SECONDS - guestUsageSeconds;
            } else if (userId && isProUser) {
              proUsageSeconds = proUsageBase + elapsed;
              remainingSec = PRO_MONTHLY_SECONDS - proUsageSeconds;
            }
            // Free signed-in users use DB-based tracking, not real-time
            // Their phase transitions happen in the 30s interval

            if (remainingSec === null) return;

            if (remainingSec <= 15 && timeWarningPhase === 'normal') {
              console.log(`[TIME] ${remainingSec}s left ‚Äî entering final_goodbye phase`);
              timeWarningPhase = 'final_goodbye';
              // If user doesn't speak within 3s, Kira says goodbye herself
              if (goodbyeTimeout) clearTimeout(goodbyeTimeout);
              goodbyeTimeout = setTimeout(() => sendProactiveGoodbye(), 3000);
            }
          }, 5000);


================================================================================
4. packages/server/src/guestUsage.ts ‚Äî Full file
================================================================================

import prisma from "./prismaClient.js";

function getToday(): string {
  return new Date().toISOString().split("T")[0]; // "YYYY-MM-DD"
}

/**
 * Get current usage for a guest. Returns 0 if no record or different day.
 */
export async function getGuestUsage(guestId: string): Promise<number> {
  const info = await getGuestUsageInfo(guestId);
  return info.seconds;
}

/**
 * Get usage info for a guest, including whether they are a returning visitor.
 * isReturning = true if any record exists at all (even from a prior day).
 */
export async function getGuestUsageInfo(guestId: string): Promise<{ seconds: number; isReturning: boolean }> {
  const today = getToday();
  try {
    // Check for any record (returning guest detection)
    const records = await prisma.guestUsage.findMany({
      where: { guestId },
      orderBy: { date: "desc" },
      take: 1,
    });

    if (records.length === 0) return { seconds: 0, isReturning: false };

    const latest = records[0];
    if (latest.date !== today) return { seconds: 0, isReturning: true };
    return { seconds: latest.seconds, isReturning: true };
  } catch (err) {
    console.error("[GuestUsage] ‚ùå Read error for", guestId, ":", err);
    return { seconds: 0, isReturning: false };
  }
}

/**
 * Save usage for a guest. Upsert for today's row; never decreases stored seconds.
 */
export async function saveGuestUsage(guestId: string, seconds: number): Promise<void> {
  const today = getToday();
  try {
    await prisma.guestUsage.upsert({
      where: { guestId_date: { guestId, date: today } },
      update: { seconds },
      create: { guestId, date: today, seconds },
    });
    console.log(`[GuestUsage] Persisted ${guestId} ${today}: ${seconds}s`);
  } catch (err) {
    console.error("[GuestUsage] ‚ùå Write error for", guestId, ":", err);
  }
}


================================================================================
5. packages/server/src/proUsage.ts ‚Äî Full file
================================================================================

import prisma from "./prismaClient.js";

function getCurrentMonth(): string {
  return new Date().toISOString().slice(0, 7); // "YYYY-MM"
}

/**
 * Get current monthly usage for a Pro user. Returns 0 if no record or different month.
 */
export async function getProUsage(clerkId: string): Promise<number> {
  const month = getCurrentMonth();
  try {
    const usage = await prisma.monthlyUsage.findUnique({
      where: { userId_month: { userId: clerkId, month } },
    });
    const seconds = usage?.seconds ?? 0;
    console.log(`[ProUsage] Read ${clerkId} ${month}: ${seconds}s`);
    return seconds;
  } catch (err) {
    console.error("[ProUsage] Read error:", err);
    return 0;
  }
}

/**
 * Save monthly usage for a Pro user (upsert ‚Äî atomic increment on existing, create if new).
 */
export async function saveProUsage(clerkId: string, seconds: number): Promise<void> {
  const month = getCurrentMonth();
  try {
    await prisma.monthlyUsage.upsert({
      where: { userId_month: { userId: clerkId, month } },
      update: { seconds },
      create: { userId: clerkId, month, seconds },
    });
    console.log(`[ProUsage] Persisted ${clerkId} ${month}: ${seconds}s`);
  } catch (err) {
    console.error("[ProUsage] Write error:", err);
  }
}


================================================================================
6. packages/web/src/hooks/useKiraSocket.ts ‚Äî State declarations (lines 130‚Äì145)
================================================================================

  const [transcript, setTranscript] = useState<{ role: "user" | "ai"; text: string } | null>(null);

  const [currentExpression, setCurrentExpression] = useState<string>("neutral");
  const [activeAccessories, setActiveAccessories] = useState<string[]>([]);
  const [currentAction, setCurrentAction] = useState<string | null>(null);
  const [error, setError] = useState<string | null>(null);
  const [isAudioBlocked, setIsAudioBlocked] = useState(false);
  const [isMuted, setIsMuted] = useState(false);
  const [isScreenSharing, setIsScreenSharing] = useState(false);
  const [isCameraActive, setIsCameraActive] = useState(false);
  const [facingMode, setFacingMode] = useState<"environment" | "user">("environment");
  const [isPro, setIsPro] = useState(false);
  const isProRef = useRef(false); // Ref mirror of isPro for use in onclose callback
  const [remainingSeconds, setRemainingSeconds] = useState<number | null>(null);
  const [isAudioPlaying, setIsAudioPlaying] = useState(false);
  const audioPlayingTimeout = useRef<ReturnType<typeof setTimeout> | null>(null);


================================================================================
7. packages/web/src/hooks/useKiraSocket.ts ‚Äî session_config handler (lines 1152‚Äì1170)
================================================================================

    onMessageRef.current = (event: MessageEvent) => {
      if (typeof event.data === "string") {
        const msg = JSON.parse(event.data);
        debugLog("[WS] ‚Üê message:", msg.type, msg.type === "session_config" ? JSON.stringify(msg).slice(0, 200) : "");

        switch (msg.type) {
          case "session_config":
            debugLog("[WS] Received session_config:", JSON.stringify(msg));
            setIsPro(msg.isPro);
            isProRef.current = msg.isPro;
            if (msg.remainingSeconds !== undefined) {
              setRemainingSeconds(msg.remainingSeconds);
            }
            break;


================================================================================
8. packages/web/src/hooks/useKiraSocket.ts ‚Äî limit_reached error + onClose (lines 1280‚Äì1380)
================================================================================

          case "error":
            if (msg.code === "limit_reached") {
              if (msg.tier === "pro") {
                debugLog("[WS] ‚ö†Ô∏è Pro monthly limit reached.");
                setError("limit_reached_pro");
              } else {
                debugLog("[WS] ‚ö†Ô∏è Daily limit reached.");
                setError("limit_reached");
              }
            } else {
              debugLog("[WS] ‚ùå Server error:", msg.message);
              setError(msg.message);
            }
            break;

    ...

    onCloseRef.current = (event: CloseEvent) => {
      debugLog("[WS] üîå Connection closed. Code:", event.code, "Reason:", event.reason, "Clean:", event.wasClean);
      setSocketState("closed");
      getConnectionStore()!.socketState = "closed";
      wsOpenRef.current = false;
      
      getConnectionStore()!.ws = null;
      getConnectionStore()!.isServerReady = false;
      getConnectionStore()!.conversationActive = false;

      if (event.code === 1008) {
        // Don't overwrite a more specific error (e.g. "limit_reached_pro")
        // If user is Pro, always use "limit_reached_pro" ‚Äî never show the free-tier paywall
        setError((prev) => {
          if (prev?.startsWith("limit_reached")) return prev;
          return isProRef.current ? "limit_reached_pro" : "limit_reached";
        });
      }

      stopAudioPipeline();
      ws.current = null;
      isServerReady.current = false;

      // Auto-reconnect logic:
      // ONLY reconnect if the conversation hasn't started yet (pre-stream connection flakiness).
      // Once a live voice session is active, reconnecting would create a fresh server session.
      if (event.code !== 1000 && event.code !== 1008) {
        if (conversationActive.current) {
          debugLog("[WS] Connection lost during active conversation ‚Äî not reconnecting");
          setError("connection_lost");
        } else if (reconnectAttempts.current < MAX_RECONNECT_ATTEMPTS) {
          const delay = Math.min(1000 * Math.pow(2, reconnectAttempts.current), 10000);
          reconnectAttempts.current++;
          getConnectionStore()!.reconnectAttempts = reconnectAttempts.current;
          debugLog(`[WS] Reconnecting in ${delay}ms (attempt ${reconnectAttempts.current}/${MAX_RECONNECT_ATTEMPTS})...`);
          setTimeout(() => {
            connect();
          }, delay);
        } else {
          setError("Connection lost. Please refresh the page.");
        }
      }
    };


================================================================================
9. packages/web/src/hooks/useKiraSocket.ts ‚Äî Return values (lines 1475‚Äì1489)
================================================================================

  return {
    connect,
    disconnect,
    startConversation,
    signalVisualReady,
    socketState,
    kiraState,
    micVolume,
    transcript,
    sendText,
    sendVoiceChange,
    error,
    isAudioBlocked,
    resumeAudio,
    isMuted,
    toggleMute,
    isScreenSharing,
    startScreenShare,
    stopScreenShare,
    isCameraActive,
    cameraStreamRef,
    facingMode,
    startCamera,
    stopCamera,
    flipCamera,
    isPro,
    remainingSeconds,
    isAudioPlaying,
    playerVolume,
    playbackAnalyserNode: playbackAnalyser.current,
    currentExpression,
    activeAccessories,
    currentAction,
  };


================================================================================
10. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Imports & state (lines 1‚Äì30)
================================================================================

"use client";

import { useAuth, useClerk } from "@clerk/nextjs";
import { useCallback, useEffect, useRef, useState } from "react";
import { useKiraSocket, debugLog } from "@/hooks/useKiraSocket";
import { PhoneOff, Star, User, Mic, MicOff, Eye, EyeOff, Clock, Sparkles, Camera } from "lucide-react";
import ProfileModal from "@/components/ProfileModal";
import KiraOrb from "@/components/KiraOrb";
import { getOrCreateGuestId } from "@/lib/guestId";
import { getVoicePreference, setVoicePreference, VoicePreference } from "@/lib/voicePreference";
import { KiraLogo } from "@/components/KiraLogo";
import dynamic from "next/dynamic";

const Live2DAvatar = dynamic(() => import("@/components/Live2DAvatar"), { ssr: false });
const XOLoader = dynamic(() => import("@/components/XOLoader"), { ssr: false });

export default function ChatClient() {
  const { getToken, userId, isLoaded: clerkLoaded } = useAuth();
  const { openSignIn } = useClerk();
  const [showRatingModal, setShowRatingModal] = useState(false);
  const hasShownRating = useRef(false);
  const [showProfileModal, setShowProfileModal] = useState(false);
  const [rating, setRating] = useState(0);
  const [hoverRating, setHoverRating] = useState(0);
  const [guestId, setGuestId] = useState("");
  const [voicePreference, setVoicePref] = useState<VoicePreference>("anime");
  const [visualMode, setVisualMode] = useState<"avatar" | "orb">("avatar");
  ...


================================================================================
11. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî handleUpgrade, handleSignUp, localRemaining (lines 230‚Äì290)
================================================================================

  const handleUpgrade = async () => {
    try {
      const res = await fetch("/api/stripe/checkout", { method: "POST" });
      if (res.ok) {
        const data = await res.json();
        window.location.href = data.url;
      } else {
        console.error("Failed to start checkout");
      }
    } catch (error) {
      console.error("Checkout error:", error);
    }
  };

  const isGuest = !userId;

  const handleSignUp = () => {
    openSignIn({
      afterSignInUrl: window.location.href,
      afterSignUpUrl: window.location.href,
    });
  };

  // --- Local countdown for time remaining ---
  const [localRemaining, setLocalRemaining] = useState<number | null>(null);

  // Sync from server when session_config arrives
  useEffect(() => {
    if (remainingSeconds !== null) {
      setLocalRemaining(remainingSeconds);
    }
  }, [remainingSeconds]);

  // Tick down every second while connected
  useEffect(() => {
    if (socketState !== "connected" || localRemaining === null) return;
    const interval = setInterval(() => {
      setLocalRemaining((prev) => (prev !== null && prev > 0 ? prev - 1 : 0));
    }, 1000);
    return () => clearInterval(interval);
  }, [socketState, localRemaining !== null]);


================================================================================
12. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Timer in header (lines ~455)
================================================================================

          {/* Timer ‚Äî only shows under 5 min remaining for free users */}
          {!isPro && localRemaining !== null && localRemaining <= 300 && localRemaining > 0 && (
            <span
              style={{
                fontSize: 12,
                fontWeight: 300,
                fontFamily: "'DM Sans', sans-serif",
                color: `rgba(201,209,217,${localRemaining <= 120 ? 0.5 : 0.25})`,
                letterSpacing: "0.06em",
              }}
            >
              {Math.floor(localRemaining / 60)}:{String(localRemaining % 60).padStart(2, "0")}
            </span>
          )}


================================================================================
13. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Error display area (lines ~700)
================================================================================

        {/* Status indicator + errors */}
        <div style={{ textAlign: "center", minHeight: 28, ... }}>
          {error && error !== "limit_reached" && error !== "limit_reached_pro" && error !== "connection_lost" && (
            <div className="mb-2 p-3 rounded relative" style={{
              background: "rgba(200,55,55,0.15)",
              border: "1px solid rgba(200,55,55,0.3)",
              color: "rgba(255,120,120,0.9)",
            }}>
              <span className="block sm:inline">{error}</span>
            </div>
          )}
          {error === "connection_lost" && (
            <div className="mb-2 p-4 rounded relative text-center" style={{
              background: "rgba(200,150,55,0.15)",
              border: "1px solid rgba(200,150,55,0.3)",
              color: "rgba(255,210,130,0.9)",
            }}>
              <p className="mb-2" style={{ fontSize: 14 }}>Connection lost. Your conversation ended.</p>
              <button
                onClick={() => window.location.reload()}
                className="px-4 py-2 rounded text-sm font-medium transition-colors"
                style={{
                  background: "rgba(139,157,195,0.2)",
                  border: "1px solid rgba(139,157,195,0.3)",
                  color: "rgba(200,210,230,0.9)",
                }}
              >
                Start New Conversation
              </button>
            </div>
          )}
        </div>


================================================================================
14. packages/web/src/app/(chat)/chat/[conversationId]/ChatClient.tsx ‚Äî Paywall overlays (lines 800‚Äì1100)
================================================================================

      {/* Limit Reached ‚Äî Paywall Overlay (Free users & Guests only, never Pro) */}
      {error === "limit_reached" && !isPro && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center"
          style={{
            background: "rgba(13,17,23,0.85)",
            backdropFilter: "blur(20px)",
            animation: "paywallFadeIn 0.6s ease both",
          }}
        >
          <div style={{
            background: "linear-gradient(135deg, rgba(20,25,35,0.95), rgba(13,17,23,0.98))",
            border: "1px solid rgba(107,125,179,0.12)",
            borderRadius: 20,
            padding: "40px 32px",
            maxWidth: 420,
            width: "100%",
            fontFamily: "'DM Sans', sans-serif",
            textAlign: "center",
            boxShadow: "0 0 80px rgba(107,125,179,0.06)",
          }}>
            {/* Clock icon */}
            <div style={{
              width: 72,
              height: 72,
              borderRadius: 18,
              background: "linear-gradient(135deg, rgba(107,125,179,0.15), rgba(107,125,179,0.05))",
              border: "1px solid rgba(107,125,179,0.2)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              margin: "0 auto 24px",
            }}>
              <Clock size={28} style={{ color: "rgba(139,157,195,0.7)" }} />
            </div>

            {isGuest ? (
              <>
                <h2 style={{
                  fontSize: 24,
                  fontFamily: "'Playfair Display', serif",
                  fontWeight: 400,
                  color: "#E2E8F0",
                  marginBottom: 10,
                  marginTop: 0,
                }}>
                  This is the beginning of something
                </h2>
                <p style={{
                  fontSize: 15,
                  fontWeight: 300,
                  color: "rgba(201,209,217,0.5)",
                  lineHeight: 1.7,
                  marginBottom: 32,
                }}>
                  Create a free account and Kira keeps building on everything
                  you just talked about ‚Äî and every conversation after.
                </p>
                <div className="flex flex-col w-full gap-3">
                  <button
                    onClick={handleSignUp}
                    style={{
                      width: "100%",
                      padding: "14px 0",
                      borderRadius: 12,
                      border: "1px solid rgba(107,125,179,0.25)",
                      background: "linear-gradient(135deg, rgba(107,125,179,0.25), rgba(107,125,179,0.1))",
                      color: "#C9D1D9",
                      fontSize: 15,
                      fontWeight: 500,
                      cursor: "pointer",
                      fontFamily: "'DM Sans', sans-serif",
                      transition: "all 0.3s ease",
                      boxShadow: "0 0 30px rgba(107,125,179,0.08)",
                    }}
                  >
                    Create free account
                  </button>
                  <a
                    href="/"
                    style={{
                      display: "block",
                      width: "100%",
                      padding: "12px 0",
                      color: "rgba(201,209,217,0.3)",
                      fontSize: 14,
                      fontWeight: 400,
                      textAlign: "center",
                      textDecoration: "none",
                      transition: "color 0.2s",
                    }}
                  >
                    I&apos;ll come back tomorrow
                  </a>
                </div>
              </>
            ) : (
              <>
                <h2 style={{
                  fontSize: 24,
                  fontFamily: "'Playfair Display', serif",
                  fontWeight: 400,
                  color: "#E2E8F0",
                  marginBottom: 10,
                  marginTop: 0,
                }}>
                  You&apos;ve used your 15 minutes
                </h2>
                <p style={{
                  fontSize: 15,
                  fontWeight: 300,
                  color: "rgba(201,209,217,0.5)",
                  lineHeight: 1.7,
                  marginBottom: 32,
                }}>
                  Upgrade to Pro for unlimited conversations,
                  priority responses, and persistent memory across sessions.
                </p>
                <div className="flex flex-col w-full gap-3">
                  <button
                    onClick={handleUpgrade}
                    style={{
                      width: "100%",
                      padding: "14px 0",
                      borderRadius: 12,
                      border: "1px solid rgba(107,125,179,0.25)",
                      background: "linear-gradient(135deg, rgba(107,125,179,0.25), rgba(107,125,179,0.1))",
                      color: "#C9D1D9",
                      fontSize: 15,
                      fontWeight: 500,
                      cursor: "pointer",
                      fontFamily: "'DM Sans', sans-serif",
                      transition: "all 0.3s ease",
                      boxShadow: "0 0 30px rgba(107,125,179,0.08)",
                    }}
                  >
                    Upgrade to Pro ‚Äî $9.99/mo
                  </button>
                  <a
                    href="/"
                    style={{
                      display: "block",
                      width: "100%",
                      padding: "12px 0",
                      color: "rgba(201,209,217,0.3)",
                      fontSize: 14,
                      fontWeight: 400,
                      textAlign: "center",
                      textDecoration: "none",
                      transition: "color 0.2s",
                    }}
                  >
                    I&apos;ll come back tomorrow
                  </a>
                </div>
              </>
            )}
          </div>
        </div>
      )}

      {/* Pro Limit Reached ‚Äî Warm Full-Screen Overlay (no upsell) */}
      {error === "limit_reached_pro" && (
        <div
          className="fixed inset-0 z-50 flex items-center justify-center"
          style={{
            background: "rgba(13,17,23,0.85)",
            backdropFilter: "blur(20px)",
            animation: "paywallFadeIn 0.6s ease both",
          }}
        >
          <div style={{
            background: "linear-gradient(135deg, rgba(20,25,35,0.95), rgba(13,17,23,0.98))",
            border: "1px solid rgba(107,125,179,0.12)",
            borderRadius: 20,
            padding: "40px 32px",
            maxWidth: 420,
            width: "100%",
            fontFamily: "'DM Sans', sans-serif",
            textAlign: "center",
            boxShadow: "0 0 80px rgba(107,125,179,0.06)",
          }}>
            <div style={{
              width: 72,
              height: 72,
              borderRadius: 18,
              background: "linear-gradient(135deg, rgba(107,125,179,0.15), rgba(107,125,179,0.05))",
              border: "1px solid rgba(107,125,179,0.2)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
              margin: "0 auto 24px",
            }}>
              <Clock size={28} style={{ color: "rgba(139,157,195,0.7)" }} />
            </div>

            <h2 style={{
              fontSize: 24,
              fontFamily: "'Playfair Display', serif",
              fontWeight: 400,
              color: "#E2E8F0",
              marginBottom: 10,
              marginTop: 0,
            }}>
              You&apos;ve had quite the month
            </h2>
            <p style={{
              fontSize: 15,
              fontWeight: 300,
              color: "rgba(201,209,217,0.5)",
              lineHeight: 1.7,
              marginBottom: 8,
            }}>
              You&apos;ve reached your monthly conversation limit.
              Your conversations and memories are safe ‚Äî Kira will be
              ready to pick up right where you left off.
            </p>
            <p style={{
              fontSize: 13,
              fontWeight: 300,
              color: "rgba(201,209,217,0.3)",
              marginBottom: 32,
            }}>
              Resets on the 1st of next month
            </p>
            <a
              href="/"
              style={{
                display: "block",
                width: "100%",
                padding: "14px 0",
                borderRadius: 12,
                border: "1px solid rgba(107,125,179,0.15)",
                background: "rgba(107,125,179,0.08)",
                color: "rgba(201,209,217,0.6)",
                fontSize: 15,
                fontWeight: 500,
                textAlign: "center",
                textDecoration: "none",
                fontFamily: "'DM Sans', sans-serif",
                transition: "all 0.3s ease",
              }}
            >
              Back to home
            </a>
          </div>
        </div>
      )}

      {/* Mobile Audio Unlock Overlay */}
      {isAudioBlocked && (
        <div className="fixed inset-0 z-50 flex items-center justify-center" style={{ background: "rgba(0,0,0,0.6)", backdropFilter: "blur(12px)" }}>
          <button
            onClick={resumeAudio}
            style={{
              display: "flex",
              flexDirection: "column",
              alignItems: "center",
              gap: 16,
              padding: "32px 40px",
              borderRadius: 16,
              background: "#0D1117",
              border: "1px solid rgba(255,255,255,0.06)",
              cursor: "pointer",
              fontFamily: "'DM Sans', sans-serif",
              transition: "transform 0.2s",
            }}
          >
            <div style={{
              width: 56,
              height: 56,
              borderRadius: 14,
              background: "linear-gradient(135deg, rgba(107,125,179,0.2), rgba(107,125,179,0.08))",
              border: "1px solid rgba(107,125,179,0.25)",
              display: "flex",
              alignItems: "center",
              justifyContent: "center",
            }}>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="rgba(139,157,195,0.7)" strokeWidth="1.8" strokeLinecap="round" strokeLinejoin="round">
                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3Z" />
                <path d="M19 10v2a7 7 0 0 1-14 0v-2" />
                <line x1="12" y1="19" x2="12" y2="22" />
              </svg>
            </div>
            <span style={{
              fontSize: 16,
              fontWeight: 500,
              color: "#C9D1D9",
            }}>Tap to Start</span>
          </button>
        </div>
      )}


================================================================================
15. packages/web/src/app/page.tsx ‚Äî handleUpgrade (lines 130‚Äì148)
================================================================================

  const handleUpgrade = useCallback(async () => {
    if (!isSignedIn) {
      openSignIn();
      return;
    }
    try {
      const res = await fetch("/api/stripe/checkout", { method: "POST" });
      if (res.ok) {
        const data = await res.json();
        window.location.href = data.url;
      }
    } catch (e) {
      console.error("Checkout error:", e);
    }
  }, [isSignedIn, openSignIn]);


================================================================================
16. packages/web/src/app/page.tsx ‚Äî Nav upgrade button (lines 218‚Äì242)
================================================================================

          {isSignedIn && !isLoading && !isPro && (
            <button
              onClick={handleUpgrade}
              style={{
                padding: "7px 18px",
                borderRadius: 8,
                fontSize: 13,
                fontWeight: 500,
                background: "rgba(107,125,179,0.12)",
                border: "1px solid rgba(107,125,179,0.2)",
                color: "#8B9DC3",
                cursor: "pointer",
                transition: "all 0.2s",
                fontFamily: "inherit",
                display: "flex",
                alignItems: "center",
                gap: 6,
              }}
            >
              <Zap size={13} />
              Upgrade
            </button>
          )}


================================================================================
17. packages/web/src/app/page.tsx ‚Äî Pricing section (lines 775‚Äì1010)
================================================================================

          {/*  PRICING                                                */}
          <section
            id="pricing"
            data-animate=""
            style={{
              padding: "100px 24px",
              maxWidth: 800,
              margin: "0 auto",
              opacity: isVisible("pricing") ? 1 : 0,
              transform: isVisible("pricing") ? "translateY(0)" : "translateY(30px)",
              transition: "all 0.8s ease",
            }}
          >
            <h2 style={{
              textAlign: "center",
              fontSize: "clamp(24px, 3.5vw, 36px)",
              fontFamily: "'Playfair Display', serif",
              fontWeight: 400,
              color: "#E2E8F0",
              marginBottom: 12,
            }}>
              Simple pricing.
            </h2>
            <p style={{
              textAlign: "center",
              fontSize: 15,
              fontWeight: 300,
              color: "rgba(201,209,217,0.45)",
              maxWidth: 400,
              margin: "0 auto 48px",
            }}>
              Try Kira for free, every day. Upgrade for unlimited conversations.
            </p>

            <div style={{
              display: "grid",
              gridTemplateColumns: "repeat(auto-fit, minmax(260px, 1fr))",
              gap: 20,
              maxWidth: 600,
              margin: "0 auto",
            }}>
              {/* Free tier */}
              <div style={{
                padding: "32px 28px",
                borderRadius: 16,
                border: "1px solid rgba(255,255,255,0.06)",
                background: "rgba(255,255,255,0.02)",
              }}>
                <div style={{
                  fontSize: 13,
                  fontWeight: 500,
                  color: "rgba(201,209,217,0.4)",
                  textTransform: "uppercase",
                  letterSpacing: "0.1em",
                  marginBottom: 16,
                }}>Free</div>
                <div style={{ display: "flex", alignItems: "baseline", gap: 4, marginBottom: 20 }}>
                  <span style={{ fontSize: 36, fontWeight: 500, color: "#C9D1D9" }}>$0</span>
                  <span style={{ fontSize: 14, color: "rgba(201,209,217,0.35)", fontWeight: 300 }}>forever</span>
                </div>
                <ul style={{
                  listStyle: "none",
                  padding: 0,
                  margin: "0 0 24px",
                  display: "flex",
                  flexDirection: "column",
                  gap: 10,
                }}>
                  {["15 minutes per day", "Full voice chat", "Camera & screen vision", "Persistent memory"].map(
                    (item, i) => (
                      <li key={i} style={{
                        fontSize: 14,
                        fontWeight: 300,
                        color: "rgba(201,209,217,0.55)",
                        display: "flex",
                        alignItems: "center",
                        gap: 8,
                      }}>
                        <span style={{ color: "rgba(107,125,179,0.5)", fontSize: 14 }}>‚úì</span> {item}
                      </li>
                    )
                  )}
                </ul>
                <a
                  href="/chat/kira"
                  style={{
                    display: "block",
                    width: "100%",
                    padding: "12px 0",
                    borderRadius: 10,
                    border: "1px solid rgba(255,255,255,0.08)",
                    background: "transparent",
                    color: "rgba(201,209,217,0.6)",
                    fontSize: 14,
                    fontWeight: 500,
                    cursor: "pointer",
                    transition: "all 0.2s",
                    fontFamily: "inherit",
                    textAlign: "center",
                    textDecoration: "none",
                  }}
                >
                  Get started
                </a>
              </div>

              {/* Pro tier */}
              <div style={{
                padding: "32px 28px",
                borderRadius: 16,
                border: "1px solid rgba(107,125,179,0.2)",
                background: "linear-gradient(135deg, rgba(107,125,179,0.06), rgba(107,125,179,0.02))",
                position: "relative",
              }}>
                <div style={{
                  position: "absolute",
                  top: -1,
                  right: 20,
                  padding: "4px 12px",
                  borderRadius: "0 0 8px 8px",
                  background: "rgba(107,125,179,0.15)",
                  fontSize: 10,
                  fontWeight: 600,
                  color: "#8B9DC3",
                  textTransform: "uppercase",
                  letterSpacing: "0.1em",
                }}>Popular</div>
                <div style={{
                  fontSize: 13,
                  fontWeight: 500,
                  color: "#8B9DC3",
                  textTransform: "uppercase",
                  letterSpacing: "0.1em",
                  marginBottom: 16,
                }}>Pro</div>
                <div style={{ display: "flex", alignItems: "baseline", gap: 4, marginBottom: 20 }}>
                  <span style={{ fontSize: 36, fontWeight: 500, color: "#C9D1D9" }}>$9.99</span>
                  <span style={{ fontSize: 14, color: "rgba(201,209,217,0.35)", fontWeight: 300 }}>/month</span>
                </div>
                <ul style={{
                  listStyle: "none",
                  padding: 0,
                  margin: "0 0 24px",
                  display: "flex",
                  flexDirection: "column",
                  gap: 10,
                }}>
                  {["Unlimited conversations", "Everything in Free", "Early access to new features", "Extended memory depth"].map(
                    (item, i) => (
                      <li key={i} style={{
                        fontSize: 14,
                        fontWeight: 300,
                        color: "rgba(201,209,217,0.55)",
                        display: "flex",
                        alignItems: "center",
                        gap: 8,
                      }}>
                        <span style={{ color: "#8B9DC3", fontSize: 14 }}>‚úì</span> {item}
                      </li>
                    )
                  )}
                </ul>
                <button
                  onClick={handleUpgrade}
                  style={{
                    width: "100%",
                    padding: "12px 0",
                    borderRadius: 10,
                    border: "none",
                    background: "linear-gradient(135deg, rgba(107,125,179,0.3), rgba(107,125,179,0.15))",
                    color: "#C9D1D9",
                    fontSize: 14,
                    fontWeight: 500,
                    cursor: "pointer",
                    transition: "all 0.2s",
                    fontFamily: "inherit",
                  }}
                >
                  Upgrade to Pro
                </button>
                <p style={{ fontSize: 12, color: "rgba(201,209,217,0.3)", marginTop: 8, textAlign: "center" }}>
                  Cancel anytime from your profile. No contracts.
                </p>
              </div>
            </div>
          </section>


================================================================================
18. packages/web/src/components/ProfileModal.tsx ‚Äî handleSubscription + Upgrade (lines 1‚Äì50, 220‚Äì285)
================================================================================

"use client";

import { useUser, useClerk } from "@clerk/nextjs";
import { useRouter } from "next/navigation";
import { useState } from "react";
import { Trash2, CreditCard, LogOut, X, User, MessageCircle } from "lucide-react";
import ConversationHistory from "./ConversationHistory";

interface ProfileModalProps {
  isOpen: boolean;
  onClose: () => void;
  isPro?: boolean;
}

export default function ProfileModal({ isOpen, onClose, isPro = false }: ProfileModalProps) {
  const { user, isLoaded, isSignedIn } = useUser();
  const { signOut, openSignIn } = useClerk();
  const router = useRouter();
  const [isDeleting, setIsDeleting] = useState(false);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [showHistory, setShowHistory] = useState(false);

  const handleSignOut = async () => {
    await signOut();
    router.push("/");
    onClose();
  };

  const handleSignIn = () => {
    openSignIn({
      afterSignInUrl: "/",
      afterSignUpUrl: "/",
    });
    onClose();
  };

  const handleSubscription = async () => {
    try {
      const portalRes = await fetch("/api/stripe/portal", { method: "POST" });
      
      if (portalRes.ok) {
        const data = await portalRes.json();
        window.location.href = data.url;
        return;
      }

      if (portalRes.status === 404) {
        const checkoutRes = await fetch("/api/stripe/checkout", { method: "POST" });
        if (checkoutRes.ok) {
          const data = await checkoutRes.json();
          ...
        }
      }
    } catch ...
  };

  ...

  {/* Actions ‚Äî Subscription section */}
  <div style={{ display: "flex", flexDirection: "column", gap: 6 }}>
    {isSignedIn ? (
      <>
        <div style={{
          fontSize: 11,
          fontWeight: 500,
          color: "rgba(107,125,179,0.5)",
          textTransform: "uppercase",
          letterSpacing: "0.12em",
          marginBottom: 6,
          marginTop: 4,
        }}>Subscription</div>

        {isPro ? (
          <button
            onClick={handleSubscription}
            style={actionBtnStyle}
          >
            <CreditCard size={16} style={{ color: "rgba(139,157,195,0.5)" }} />
            Manage Subscription
          </button>
        ) : (
          <button
            onClick={handleSubscription}
            style={{
              width: "100%",
              padding: "12px 0",
              borderRadius: 10,
              border: "none",
              background: "linear-gradient(135deg, rgba(107,125,179,0.3), rgba(107,125,179,0.15))",
              color: "#C9D1D9",
              fontSize: 14,
              fontWeight: 500,
              cursor: "pointer",
              fontFamily: "'DM Sans', sans-serif",
              transition: "all 0.2s",
            }}
          >
            Upgrade to Pro
          </button>
        )}
      </>
    ) : ...}
  </div>


================================================================================
19. packages/web/src/app/api/stripe/checkout/route.ts ‚Äî Full file
================================================================================

import { auth, currentUser } from "@clerk/nextjs/server";
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { stripe } from "@/lib/stripe";

const ALLOWED_ORIGINS = [
  "https://www.xoxokira.com",
  "https://xoxokira.com",
  ...(process.env.NODE_ENV !== "production" ? ["http://localhost:3000"] : []),
];

export async function POST(req: Request) {
  try {
    // CSRF protection: verify the request originates from our own site
    const origin = headers().get("origin");
    if (!origin || !ALLOWED_ORIGINS.includes(origin)) {
      return new NextResponse("Forbidden", { status: 403 });
    }

    const { userId } = auth();
    const user = await currentUser();

    if (!userId || !user) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const userEmail = user.emailAddresses[0].emailAddress;

    // 1. Get or Create User in DB
    let dbUser = await prisma.user.findUnique({
      where: { clerkId: userId },
    });

    if (!dbUser) {
      dbUser = await prisma.user.create({
        data: {
          clerkId: userId,
          email: userEmail,
          name: `${user.firstName} ${user.lastName}`,
        },
      });
    }

    // 2. Create Stripe Customer if needed
    let stripeCustomerId = dbUser.stripeCustomerId;

    if (!stripeCustomerId) {
      const customer = await stripe.customers.create({
        email: userEmail,
        name: `${user.firstName} ${user.lastName}`,
        metadata: {
          userId: userId,
        },
      });
      stripeCustomerId = customer.id;
      await prisma.user.update({
        where: { id: dbUser.id },
        data: { stripeCustomerId },
      });
    }

    // 3. Create Checkout Session
    const priceId = process.env.STRIPE_PRICE_ID;
    const appUrl = process.env.NEXT_PUBLIC_APP_URL;

    if (!priceId) {
        console.error("Stripe Price ID missing");
        return new NextResponse("Stripe Price ID missing", { status: 500 });
    }

    if (!appUrl) {
        console.error("NEXT_PUBLIC_APP_URL missing");
        return new NextResponse("App URL configuration missing", { status: 500 });
    }

    console.log(`[STRIPE_CHECKOUT] Creating session for ${userEmail} with price ${priceId} return to ${appUrl}`);

    const session = await stripe.checkout.sessions.create({
      customer: stripeCustomerId,
      line_items: [
        {
          price: priceId,
          quantity: 1,
        },
      ],
      mode: "subscription",
      success_url: `${appUrl}/?success=true`,
      cancel_url: `${appUrl}/?canceled=true`,
      metadata: {
        userId: userId,
      },
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("[STRIPE_CHECKOUT]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}


================================================================================
20. packages/web/src/app/api/stripe/portal/route.ts ‚Äî Full file
================================================================================

import { auth, currentUser } from "@clerk/nextjs/server";
import { headers } from "next/headers";
import { NextResponse } from "next/server";
import prisma from "@/lib/prisma";
import { stripe } from "@/lib/stripe";

const ALLOWED_ORIGINS = [
  "https://www.xoxokira.com",
  "https://xoxokira.com",
  ...(process.env.NODE_ENV !== "production" ? ["http://localhost:3000"] : []),
];

export async function POST(req: Request) {
  try {
    // CSRF protection: verify the request originates from our own site
    const origin = headers().get("origin");
    if (!origin || !ALLOWED_ORIGINS.includes(origin)) {
      return new NextResponse("Forbidden", { status: 403 });
    }

    const { userId } = auth();
    
    if (!userId) {
      return new NextResponse("Unauthorized", { status: 401 });
    }

    const dbUser = await prisma.user.findUnique({
      where: { clerkId: userId },
    });

    if (!dbUser || !dbUser.stripeCustomerId) {
      return new NextResponse("User not found or no stripe customer", { status: 404 });
    }

    const appUrl = process.env.NEXT_PUBLIC_APP_URL;
    if (!appUrl) {
        console.error("NEXT_PUBLIC_APP_URL missing");
        return new NextResponse("App URL configuration missing", { status: 500 });
    }

    const session = await stripe.billingPortal.sessions.create({
      customer: dbUser.stripeCustomerId,
      return_url: `${appUrl}/`,
    });

    return NextResponse.json({ url: session.url });
  } catch (error) {
    console.error("[STRIPE_PORTAL]", error);
    return new NextResponse("Internal Error", { status: 500 });
  }
}


================================================================================
21. packages/web/src/app/api/webhooks/stripe/route.ts ‚Äî Full file
================================================================================

import { headers } from "next/headers";
import { NextResponse } from "next/server";
import Stripe from "stripe";
import prisma from "@/lib/prisma";
import { stripe } from "@/lib/stripe";

export async function POST(req: Request) {
  const body = await req.text();
  const signature = headers().get("Stripe-Signature") as string;

  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!webhookSecret) {
    console.error("[STRIPE_WEBHOOK] STRIPE_WEBHOOK_SECRET is not set!");
    return new NextResponse("Webhook configuration error", { status: 500 });
  }

  let event: Stripe.Event;

  try {
    event = stripe.webhooks.constructEvent(
      body,
      signature,
      webhookSecret
    );
  } catch (error: any) {
    console.error(`[STRIPE_WEBHOOK_ERROR] Signature verification failed: ${error.message}`);
    return new NextResponse("Webhook signature verification failed", { status: 400 });
  }

  console.log(`[STRIPE_WEBHOOK] Received event: ${event.type}`, { id: event.id });

  if (event.type === "checkout.session.completed") {
    const session = event.data.object as Stripe.Checkout.Session;
    const subscription = await stripe.subscriptions.retrieve(
      session.subscription as string
    );

    if (!session?.metadata?.userId) {
      return new NextResponse("User id is required", { status: 400 });
    }

    await prisma.user.update({
      where: {
        clerkId: session.metadata.userId,
      },
      data: {
        stripeSubscriptionId: subscription.id,
        stripeCustomerId: subscription.customer as string,
        stripePriceId: subscription.items.data[0].price.id,
        stripeCurrentPeriodEnd: new Date(
          subscription.current_period_end * 1000
        ),
      },
    });
  }

  if (event.type === "invoice.payment_succeeded") {
    const invoice = event.data.object as Stripe.Invoice;
    const subscription = await stripe.subscriptions.retrieve(
      invoice.subscription as string
    );

    await prisma.user.update({
      where: {
        stripeSubscriptionId: subscription.id,
      },
      data: {
        stripePriceId: subscription.items.data[0].price.id,
        stripeCurrentPeriodEnd: new Date(
          subscription.current_period_end * 1000
        ),
      },
    });
  }

  if (event.type === "customer.subscription.deleted") {
    const subscription = event.data.object as Stripe.Subscription;

    await prisma.user.update({
      where: {
        stripeSubscriptionId: subscription.id,
      },
      data: {
        stripeSubscriptionId: null,
        stripePriceId: null,
        stripeCurrentPeriodEnd: null,
      },
    });
    console.log(`[STRIPE_WEBHOOK] Subscription ${subscription.id} cancelled ‚Äî cleared user fields`);
  }

  return new NextResponse(null, { status: 200 });
}


================================================================================
22. packages/web/src/lib/stripe.ts ‚Äî Full file
================================================================================

import Stripe from "stripe";

const apiKey = process.env.STRIPE_SECRET_KEY;

if (!apiKey) {
  console.error("‚ö†Ô∏è STRIPE_SECRET_KEY is missing in environment variables! Stripe calls will fail.");
}

export const stripe = new Stripe(apiKey || "", {
  apiVersion: "2024-06-20",
  typescript: true,
});


================================================================================
23. packages/web/src/app/globals.css ‚Äî paywallFadeIn animation
================================================================================

/* Paywall overlay entrance animation */
@keyframes paywallFadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}


================================================================================
END OF PAYWALL FILES AUDIT
================================================================================

FLOW SUMMARY:
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. SERVER: On connect ‚Üí checks usage (guest/free/pro) via DB ‚Üí sends `session_config { isPro, remainingSeconds }` or immediately sends `limit_reached` + closes WS
2. SERVER: 30s interval ‚Üí persists usage to DB, catches over-limit for free signed-in users
3. SERVER: 5s interval ‚Üí computes remaining time live ‚Üí enters `final_goodbye` at ‚â§15s remaining
4. SERVER: `final_goodbye` ‚Üí if user speaks, LLM generates goodbye (1 sentence, max_tokens 60) ‚Üí TTS ‚Üí `limit_reached` ‚Üí ws.close(1008)
5. SERVER: `final_goodbye` ‚Üí if user silent for 3s ‚Üí `sendProactiveGoodbye()` ‚Üí same flow
6. CLIENT: `session_config` ‚Üí sets `remainingSeconds` ‚Üí `localRemaining` ticks down every 1s
7. CLIENT: Timer shown in header when ‚â§5 min remaining (free only), brightens at ‚â§2 min
8. CLIENT: `limit_reached` error ‚Üí shows paywall overlay (guest: "Create free account" / free: "Upgrade to Pro ‚Äî $9.99/mo")
9. CLIENT: `limit_reached_pro` error ‚Üí shows warm "You've had quite the month" overlay
10. CLIENT: Upgrade button ‚Üí POST /api/stripe/checkout ‚Üí Stripe Checkout Session ‚Üí redirect
11. CLIENT: Profile modal ‚Üí "Manage Subscription" (pro) or "Upgrade to Pro" (free) ‚Üí portal or checkout
12. STRIPE WEBHOOK: checkout.session.completed ‚Üí updates user with subscription data
13. STRIPE WEBHOOK: customer.subscription.deleted ‚Üí clears subscription fields (cancellation)
